// notes for self-use 01.10.22
**: Referring to Components
++: Referring to some key terms

/* 
  Lectures Covered:
  Setting Up Redux 1
  Setting Up Redux 2
*/

Summary: 
- setting up redux; configuring. 
- wrap entire application with <Provider> so whole app has access to redux. (?)
- redux folder under src, and inside redux we have root-reducer and store. 
- each slice of different reducer will be in its own folder & reducer (e.g. user reducer).
- in the slice of the reducer, e.g. user, we have this reducer _function_ that takes in 
  a state (initial / current state) and an action. 
- use switch case (can also use if-else) and if an action match the state will be updated. 
- action will be in its own file;
  the action has two parts: 1) type 2) payload; type is a string, and payload can be anything;
  in this case, the type is SET_CURRENT_USER and the payload is user. 
- import in the slice of the reducer into root-reducer, which is to be passed into store to have redux work. 

# Setting Up Redux
- Action -- Middleware --> Root Reducer -> Store -> DOM changes

- +middleware+ is a piece of code that gets the action before the root reducuer. 

Code #1:
// index.js

// the new component we get from react-redux that will give our 
// application access to the store and reducers
```
import { Provider } from 'react-redux';
```

- *Provider* should be wrapped around the entire application. 

- just like what was done for firebase, a new folder called redux 
  will be created under src. 

- we will first write the +root-reducer+. It is the base object that
  represents all of the state of the application. 

- will be writing reducer for +user+. Anything related to user will go under here;
  right now, currentUser state lives in App.js. 

- reducer gets the +initial state+ and +action+; action consists of type and a payload. 

- the state is something redux +store+ going to pass to the reducer 
  whenever an action fires; the state is whatever the state is currently
  when the action gets fired. 

- when the state is fired for the first time, it's going to be nothing bc redux doesn't know;
  and therefore we need to set an initial state, just like what we usually do in 
  this.state = {};

Code #2:
```
const INITIAL_STATE = { currentUser: null }; 
// default param, if state is ever undefined it will be set to INITIAL_STATE
const userReducer = (state = INITIAL_STATE, action) =>
```

- every single reducer gets every single action that ever gets fired,
  even if the action are not related to the reducer; 
  that's why we default return the state;

- export userReducer and bring it into the root-reducer. 

- in order to combine all the reducers, need to import in a function 
  called +combineReducers+ from redux library inside root-reducer.

- next step is to bring it into the store;
  create new store.js under redux. 

- +createStore+ needs to be imported as well as +applyMiddleware+;
  middleware is for whenever action gets fired or dispatched, we can 
  catch and display them; logger is useful for debugging redux code.

- the middleware the store is expecting is in the form of an array. 

Code #3:
```
const middlewares = [logger];
```

- to actually create the store, we use +createStore+ which gets a 
  root reducer and the return value from applyMiddleware which we spread in middlewares.

Code #4:
// the spread operator will spread in all the values in the array into
// the function applyMiddleware as individual arguments. 
```
  const store = createStore(rootReducer, applyMiddleware(...middlewares));
``` 

- the above was done so the code is more scalable, because if there were
  new middleware, we would only have to make changes to the const middlewares;

Code #5:
// we could've done this
```
  const store = createStore(rootReducer, applyMiddleware(logger));
```

- after store is exported out, we bring it into index.js into *Provider*. 